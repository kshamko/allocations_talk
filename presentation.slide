Escape Analysis & Profiling og Go Applications

Kanstantsin Shamko
Erlang developer at [[https://www.idt.net/][IDT]]

* Agenda 
- Garbage collector
- Escape analysis
- Profiling tools

* Memory Model of Golang

.image img/memmodel.png
  
- each goroutine has own *stack*
- *stack* represents state of execution (hold function call and their local variables)
- default stack size is 8KB. Could be resided by the Go Runtime
- *heap* holds variables (i.e. pointers, arrays, data structures) 
- garbage collector cleans *heap*  

* Garbage Collector
** Heap Befor GC 
.image img/gc1.jpg

* Garbage Collector
** Heap After GC 
.image img/gc2.jpg

- GC locates memory blocks which have no pinters on them
- GC cleans located blocks


* Garbage Collector
** Memory Usage Graph
.image img/gc3.jpg

* Garbage Collector
** GOGC

- env variable
- controls the agressivness of GC
- GOGC=200 => GC cycle will start when heap grows to 200% of the prev size
- GOGC=off

* Garbage Collector
** Relatively Low Memory Usage

.image img/gc4.jpg

* Garbage Collector
** Large and Stable Memory Usage

.image img/gc5.jpg


* Garbage Collector
** App lives for a short time

 GOGC=off go build ...

* Memory Allocation

- 2 types of allocations:
 - stack allocation (cheap)
 - heap allocation (expensive)
- Go Runtime manages allocations automatically. No way to say where to allocate

* Memory Allocation
** Stack Allocation
- in a local stack for each goroutine
- cheap because requires 2 CPU instructions: push to stack, release from stack
- requires that the lifetime and memory footprint of var can be determined at *compile time*

* Memory Allocation
** Heap Allocation
- in a global heap for dynamic allocations
- expensive because:
- it is required to search for a chunk of free memory large enough for a var
- garbage collection
- occurs at *run time*

* Escape Analysis

- compiler's technique to choose between 2 types of allocations
- not an optimization but can be used for that
- rules of escape analysis not a part of Go specification
- rules could be changed. make an experimentation

* Escape Analysis

.code example1/escape_example.go

 $ go build -gcflags '-m' ./escape_example.go

*-m* - print optimization decision

.image img/escape1.png

 $ go build -gcflags '-m -m' ./escape_example.go

.image img/escape2.png

