Escape Analysis & Profiling of Go Applications

Kanstantsin Shamko
Erlang developer at [[https://www.idt.net/][IDT]]

* Agenda 
- Garbage collector
- Escape analysis
- Profiling tools

* Memory Model of Golang
.image img/memmodel.png
- each goroutine has own *stack*
- *stack* represents state of execution (hold function call and their local variables)
- default stack size is 8KB. Could be resided by the Go Runtime
- *heap* holds variables (i.e. pointers, arrays, data structures) 
- garbage collector cleans *heap*  

* Garbage Collector

* Heap Before GC
.image img/gc1.jpg _ 500

* Heap After GC 
.image img/gc2.jpg _ 400
- GC locates memory blocks which have no pinters on them
- GC cleans located blocks

* Memory Usage Plot
.image img/gc3.jpg 400 _

* Garbage Collector Settings
.html img/gogc.html
- env variable
- controls the agressivness of GC
- GOGC=200 => GC cycle will start when heap grows to 200% of the prev size
- GOGC=off

* Relatively Low Memory Usage
.image img/gc4.jpg 350 _

* Large and Stable Memory Usage
.image img/gc5.jpg 400 _

* App lives for a short time
 GOGC=off go build ...

* Memory Allocation

* Types of Allocation
- stack allocation (cheap)
- heap allocation (expensive)
Go Runtime manages allocations automatically. No way to say where to allocate

* Stack Allocation
- in a local stack for each goroutine
- cheap because requires 2 CPU instructions: push to stack, release from stack
- requires that the lifetime and memory footprint of var can be determined at *compile time*

* Heap Allocation
- in a global heap for dynamic allocations
- expensive because:
- it is required to search for a chunk of free memory large enough for a var
- garbage collection
- occurs at *run time*

* Escape Analysis

* What Is It?
- compiler's technique to choose between 2 types of allocations
- not an optimization but can be used for that
- rules of escape analysis not a part of Go specification
- rules could be changed. make an experimentation

* Escape Example
.code example1/escape_example.go
 $ go build -gcflags '-m' ./escape_example.go
.image img/escape1.png
 $ go build -gcflags '-m -m' ./escape_example.go
.image img/escape2.png

